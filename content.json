{"meta":{"title":"Tian-Xing's blog","subtitle":null,"description":null,"author":"Tian-Xing","url":"","root":"/"},"pages":[{"title":"关于","date":"2018-12-12T14:14:36.000Z","updated":"2019-10-10T11:53:40.549Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[Tian-Xing's blog] 与&nbsp; Tian-Xing&nbsp; （ 您好（こんにちは） ） 对话中... bot_ui_ini()"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-08-27T23:07:21.455Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":""},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-08-27T23:07:21.473Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载："},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-08-27T23:07:21.511Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":""},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-08-27T23:07:21.531Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-08-27T23:07:21.492Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"友链","date":"2018-12-19T15:11:06.000Z","updated":"2019-10-16T01:51:03.881Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-08-27T23:07:21.568Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-08-27T23:07:21.586Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-12-12T14:14:16.000Z","updated":"2019-10-20T01:54:09.681Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-08-27T23:07:21.624Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-08-27T23:07:21.668Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }"}],"posts":[{"title":"莫比乌斯反演学习笔记","slug":"莫比乌斯反演学习笔记","date":"2019-10-18T07:05:34.000Z","updated":"2019-10-20T01:43:34.654Z","comments":true,"path":"2019/10/18/莫比乌斯反演学习笔记/","link":"","permalink":"/2019/10/18/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"$\\phi \\ast 1=id 的证明$ $\\phi(p^k)\\ast1$$=\\sum_{d|p^k}\\phi(d)$$=\\sum_{i=0}^k\\phi(p^i)$$=\\sum_{i=0}^k(p^i-p^{i-1})$$=p^k$ $由于\\phi \\ast 1是积性函数，所以\\phi \\ast 1(n)=\\prod_{i=1}^k\\phi \\ast 1(pi)=\\prod_{i=1}^kpi=id,所以\\phi \\ast 1=id$","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"}],"author":"Tian-Xing"},{"title":"dp优化","slug":"dp优化","date":"2019-10-09T01:54:33.000Z","updated":"2019-10-18T07:19:04.776Z","comments":true,"path":"2019/10/09/dp优化/","link":"","permalink":"/2019/10/09/dp%E4%BC%98%E5%8C%96/","excerpt":"","text":"dp真是好玩呢，有好多有趣且优美的优化。 四边形不等式优化首先，什么是四边形不等式？一句话来概括，就是：相交小于包含一维二维的满足四边形不等式的dp式子都具有决策单调性，都可以被优化二维的太复杂了,我只写一维的好了令$w(x,y)$是定义在整数集合上的二元函数，对于$a&lt;=b&lt;=c&lt;=d$,有$w(a,c)+w(b,d)&lt;=w(a,d)+w(b,c)$，则称此函数满足四边形不等式。但是在dp的时候，这种式子不常出现，对于两个确定的i和j，如何确定该函数满足四边形不等式呢？有如下的定理:对于$a&lt;b$，有$w(a,b+1)+w(a+1,b)&gt;=w(a+1,b+1)+w(a,b)$成立，则此函数满足四边形不等式。证明如下： 对于$a&lt;c$,有$w(a,c+1)+w(a+1,c)&gt;=w(a,c)+w(a+1,c+1)$对于$a+1&lt;c$，有$w(a+1,c+1)+w(a+2,c)&gt;=w(a+1,c)+w(a+2,c+1)$两式相加，得到$w(a,c+1)+w(a+2,c)&gt;=w(a,c)+w(a+2,c+1)$以此类推，对任意的$a&lt;=b&lt;=c$，有$w(a,c+1)+w(b,c)&gt;=w(a,c)+w(b,c+1)$同理，对于任意的$a&lt;=b&lt;=c&lt;=d$,有$w(a,d)+w(b,c)&gt;=w(a,c)+w(b,d)$$Q.E.D.$ 那么，四边形不等式如何优化dp呢？对于一维的dp，我们可以将形如$dp[i]=min_{i=0}^j(dp[j]+w(i,j))$的式子优化，因为它具有决策单调性，于是我们用一个单调队列来维护每个i的最优更新的j，就可以在$O(nlogn)$的复杂度内求解问题。 我们来看一下为什么具有决策单调性 令$p[i]$表示对于点$i$的最优决策点那么任选$0&lt;=j&lt;i$，$j$更新$i$一定比$p[i]$更新$i$更劣所以得到式子1:$dp[p[i]]+w(p[i],i)&lt;=dp[j]+w(j,i)$接着我们任选$i+1&lt;=q&lt;+n$，因为函数$w$满足四边形不等式，所以我们得到式子2:$w(j,q)+w(p[i],i)&gt;=w(p[i],q)+w(j,i)$对式子2移项，得:$w(p[i],q)-w(p[i],i)&lt;=w(j,q)-w(j,i)$与式子1相加，得:$dp[p[i]]+w(p[i],q)&lt;=dp[j]+w(j,q)$也就是说，以$p[i]$为决策点来转移$q$比以$j$为决策点转移$q$更优所以对于$p[i]$之前的所有决策点都不如$p[i]$来转移$i$之后的点更优，即决策单调性$Q.E.D$ 那么我们怎么来维护这些决策点呢？用一个单调队列维护即可,单调队列里面用结构体存储决策点存储决策点的位置,决策点可以优化的点的区间的左端点，右端点。每次加入一个新的决策点的时候若新加的决策点比一整个决策点可以优化的区间都优秀，就直接将这个决策点出队如果比这个决策点可以优化的区间都劣，就将当前的决策点扔到单调队列的队尾否则在这个决策点的可优化区间里二分一个点，使得这个点之前都是这个决策点优化更优，这个点之后都是新加进去的决策点更优，改变队尾结构体里记录的值，将当前的决策点入队即可。 NOI2009诗人小G 题目描述小G是一个出色的诗人，经常作诗自娱自乐。但是，他一直被一件事情所困扰，那就是诗的排版问题。 一首诗包含了若干个句子，对于一些连续的短句，可以将它们用空格隔开并放在一行中，注意一行中可以放的句子数目是没有限制的。小G给每首诗定义了一个行标准长度（行的长度为一行中符号的总个数），他希望排版后每行的长度都和行标准长度相差不远。显然排版时，不应改变原有的句子顺序，并且小G不允许把一个句子分在两行或者更多的行内。在满足上面两个条件的情况下，小G对于排版中的每行定义了一个不协调度, 为这行的实际长度与行标准长度差值绝对值的P次方，而一个排版的不协调度为所有行不协调度的总和。 小G最近又作了几首诗，现在请你对这首诗进行排版，使得排版后的诗尽量协调（即不协调度尽量小），并把排版的结果告诉他。 输入格式输入文件中的第一行为一个整数T，表示诗的数量。 接下来为T首诗，这里一首诗即为一组测试数据。每组测试数据中的第一行为三个由空格分隔的正整数N，L，P，其中：N表示这首诗句子的数目，L表示这首诗的行标准长度，P的含义见问题描述。 从第二行开始，每行为一个句子，句子由英文字母、数字、标点符号等符号组成（ASCII码33～127，但不包含’-‘）。 输出格式于每组测试数据，若最小的不协调度不超过10^18，则第一行为一个数，表示不协调度。接下来若干行，表示你排版之后的诗。注意：在同一行的相邻两个句子之间需要用一个空格分开。 如果有多个可行解，它们的不协调度都是最小值，则输出任意一个解均可。若最小的不协调度超过10^18，则输出“Too hard to arrange”（不含引号）。每组测试数据结束后输出“——————–”（不含引号），共20个“-”，“-”的ASCII码为45，请勿输出多余的空行或者空格。 $显然令dp[i]表示前i句诗的最小不协调值，sum[i]为前i句诗的前缀和长度$$有状态转移方程:dp[i]=min_{i=0}^jabs(sum[i]-sum[j]+i-j-1-L)^p$$我们如果证明这个式子可以用四边形不等式优化，就可以O(nlogn)求出答案$$设w(i,j)=abs(sum[i]-sum[j]+i-j-1-L)^p$$那么如果w(a,b+1)+w(a+1,b)&gt;=w(a+1,b+1)+w(a,b)，就可以说明它满足四边形不等式$$那么只需证明w(a+1,b)-w(a+1,b+1)&gt;=w(a,b)-w(a,b+1)即可$$令b1=sum[b]+b-sum[a]-a-l-1,b2=sum[b]+b-sum[a]-a-1-l-1$$只需证明abs(b2)^p-abs(b2+(a[i+1]+1))^p&gt;=abs(b1)^p-abs(b1+(a[i+1]+1))^p即可$$易得，b2&gt;b1,那么只需证明对于任意的常数c,函数y=abs(x)^p-abs(x+c)^p单调递减$我太菜了不会证明emmmm，引用算法竞赛进阶指南 当p为奇数，x为负数原函数为y=-x^p-(x+c)^p，求导，发现y’&lt;=0，所以单调递减其他情况大力分类讨论 CODE#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; #define ll long long const double eps=1e-8; long double ksm(long double a,ll b) { long double tmp=1; while(b) { if(b&amp;1)tmp=tmp*a; a=a*a; b&gt;&gt;=1; } return tmp; } int n,head,tail,ans[200050]; string stt[200050]; ll sum[200050],p,l; long double f[200050]; struct node { int j,l,r; }q[5000050]; long double abss(ll x) { return x&lt;0?-x:x; } long double zhi(int j,int i) { return ksm(abss((sum[i]-sum[j])+(i-j-1)-l),p); } void print(int n) { if(!n)return; int t=ans[n];print(t); for(int i=t+1;i&lt;=n;i++) { cout&lt;&lt;stt[i]; if(i!=n)putchar(&#39; &#39;); } printf(&quot;\\n&quot;); } int query(int l,int r,int i,int j) { int mid;++r; while(l&lt;r) { mid=(l+r)&gt;&gt;1; if(f[j]+zhi(j,mid)&gt;f[i]+zhi(i,mid))l=mid+1; else r=mid; } return l; } int main() { int kkk; scanf(&quot;%d&quot;,&amp;kkk); while(kkk--) { memset(ans,0,sizeof(ans)); head=1;tail=0; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;l,&amp;p); for(int i=1;i&lt;=n;i++)cin&gt;&gt;stt[i],sum[i]=sum[i-1]+stt[i].size(); f[0]=0; for(int i=1;i&lt;=n;i++) { while(head&lt;=tail &amp;&amp; f[i-1]+zhi(i-1,q[tail].l)&lt;=f[q[tail].j]+zhi(q[tail].j,q[tail].l))tail--; if(head&lt;=tail) { int pos=query(q[tail].l,q[tail].r,q[tail].j,i-1); if(pos&lt;=n)q[tail].r=pos-1,q[++tail]=(node){i-1,pos,n}; } else q[++tail]=(node){i-1,i,n}; while(head&lt;=tail &amp;&amp; q[head].r&lt;i)++head; if(head&lt;=tail)q[head].l=i; int pos=q[head].j; f[i]=f[pos]+zhi(pos,i),ans[i]=pos; } if(f[n]-1e18&gt;eps)printf(&quot;Too hard to arrange\\n&quot;); else { printf(&quot;%lld\\n&quot;,(ll)(f[n])); print(n); } printf(&quot;--------------------&quot;); if(kkk)printf(&quot;\\n&quot;); } return 0; }","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"DP","slug":"DP","permalink":"/tags/DP/"}],"author":"Tian-Xing"},{"title":"CF286C Main Sequence","slug":"CF286C-Main-Sequence","date":"2019-10-07T13:40:50.000Z","updated":"2019-10-18T07:19:18.182Z","comments":true,"path":"2019/10/07/CF286C-Main-Sequence/","link":"","permalink":"/2019/10/07/CF286C-Main-Sequence/","excerpt":"","text":"解题思路看到此题中的括号一词，我们不难想到栈这个东西 因为有左括号，则必有右括号 因为后扫到的左括号先和右括号匹配，所以可以用栈维护 那么我们就从右边开始向左边扫，扫到一个位置不能和栈顶元素匹配或者已经被钦定为右括号，就把他丢进右括号的栈里 为什么从右边开始扫呢？ 因为题目给出的是钦定的右括号，也就是说这些位置一定是右括号 如果从左边开始则不能很好的满足这些数是右括号的条件 所以从右边开始贪心即可 若扫到的元素不能和栈顶元素匹配，如果把它和别的元素匹配，就会导致一个括号被忽略的情况，所以不能和栈顶匀速匹配就进栈 方案的话如果是右括号就是-，左括号就是+ CODE#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; #define int long long int n,m,top=0; int a[2000050],stack[2000050],b[2000050],answer[2000050]; signed main() { scanf(&quot;%lld&quot;,&amp;n); for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]); scanf(&quot;%lld&quot;,&amp;m); int x; for(int i=1;i&lt;=m;i++)scanf(&quot;%lld&quot;,&amp;x),b[x]=1; for(int i=n;i&gt;=1;i--) { if(a[i]!=stack[top] || b[i]==1)stack[++top]=a[i],answer[i]=-1; else top--,answer[i]=1; } if(top)printf(&quot;NO&quot;); if(!top)printf(&quot;YES\\n&quot;); if(!top)for(int i=1;i&lt;=n;i++)printf(&quot;%lld &quot;,answer[i]*a[i]); return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"栈","slug":"栈","permalink":"/tags/%E6%A0%88/"}],"author":"Tian-Xing"},{"title":"贪心算法经典例题","slug":"贪心算法经典例题","date":"2019-09-28T08:09:10.000Z","updated":"2019-10-18T07:19:31.509Z","comments":true,"path":"2019/09/28/贪心算法经典例题/","link":"","permalink":"/2019/09/28/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98/","excerpt":"","text":"贪心算法真是令人头疼的一个模块啊考场上怎么想都想不出来代码却常常很短…… 仓库选址 描述在一条数轴上有N家商店，它们的坐标分别为 A[1]-A[N]。现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。输入格式第一行一个整数N，第二行N个整数A[1]-A[N]。输出格式一个整数，表示距离之和的最小值。样例输入46 2 9 1样例输出12数据范围与约定对于100%的数据: N&lt;=100000, A[i]&lt;=1000000 这道题的答案其实就是所有点距离的中位数我们来证明一下假设我们所有点中距离中位数的点是k那么答案就是$\\sum_{i=1}^n(a[i]-a[k])$假设有另外一个点比它更优，这个点为q那么我们一定可以通过平移点k来得到点q假如我们平移U点，U点左边有left个点，右边有right个点,那么右移后新的答案会加left乘平移距离，减right乘平移距离，左移后新的答案会加right乘平移距离，减left乘平移距离若需将k左移则必定有left&gt;right那么必定k点比q点更优，右移同理综上，答案就是所有点距离的中位数 均分纸牌 题目描述 Description有 N 堆纸牌，编号分别为 1，2，…, N。每堆上有若干张，但纸牌总数必为 N 的倍数。可以在任一堆上取若于张纸牌，然后移动。 移牌规则为：在编号为 1 堆上取的纸牌，只能移到编号为 2 的堆上；在编号为 N 的堆上取的纸牌，只能移到编号为 N-1 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。 现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。 例如 N=4，4 堆纸牌数分别为： ① 9 ② 8 ③ 17 ④ 6 移动3次可达到目的： 从 ③ 取 4 张牌放到 ④ （9 8 13 10） -&gt; 从 ③ 取 3 张牌放到 ②（9 11 10 10）-&gt; 从 ② 取 1 张牌放到①（10 10 10 10）。输入描述 Input Description第一行N（N 堆纸牌，1 &lt;= N &lt;= 100）第二行A1 A2 … An （N 堆纸牌，每堆纸牌初始数，l&lt;= Ai &lt;=10000）输出描述 Output Description输出至屏幕。格式为：所有堆均达到相等时的最少移动次数。样例输入 Sample Input49 8 17 6样例输出 Sample Output3 首先我们可以看出，如果所有纸牌数量加起来的和除以人数不是整数的话，此题无解所以均分纸牌后，每个人手里都有纸牌数的平均数个纸牌。那么我们只需要从第一个人开始依次向后面递推模拟即可 如果下一个人的纸牌数量比平均数多，那么就从当前人向下一个人移动纸牌如果当前的的人的纸牌数量比平均数少，就从下一个人手里取走纸牌按此规则进行模拟即可 用s数组存纸牌数量的前缀和这时我们发现其实答案就是$\\sum_{i=1}^nabs(s[i]-i*平均数)$显然我们在模拟到k个的时候前面k-1个都已经均分好了，只需处理第k个，按照规则进行转移即可那这样我们发现一个等价做法，我们可以在前缀和之前就将纸牌数量都减少平均数个显然a数组现在表示纸牌与其他纸牌堆的差值再把处理后的a数组前缀和的绝对值加起来即可之所以前缀和是因为前面的纸牌的移动会对后面造成影响 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; using namespace std; int n; int a[500050],s[500050]; int abs(int x) { return x&gt;0?x:-x; } int main() { scanf(&quot;%d&quot;,&amp;n); int zws=0; for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]),zws+=a[i]; zws/=n; int answer=0; for(int i=1;i&lt;=n;i++)s[i]=s[i-1]+a[i],answer+=i*zws!=s[i]?1:0; printf(&quot;%d&quot;,answer); return 0; } 环形均分纸牌 题目描述有n个小朋友坐成一圈，每人有ai个糖果。每人只能给左右两人传递糖果。每人每次传递一个糖果代价为1。输入格式小朋友个数n 下面n行 ai输出格式求使所有人获得均等糖果的最小代价。输入输出样例输入41254输出4 我们考虑环形均分纸牌可以进行破环成链，那么一个环就有环上点个数种情况(可以从任意点断开)用a表示减去平均数之后的纸牌数量，s表示对a的前缀和假设从k处断开，那么这个环就断成了一条链…………………………a[k+1] s[k+1]-s[k]a[k+2] s[k+2]-s[k]…………………………a[n] s[n]-s[k]a[1] s[1]+s[n]-s[k]…………………………a[k] s[k]+s[n]-s[k]因为此处a数组已经减去平均数了，所以s[n]=0也就是说，答案是$\\sum_{i=1}^n(s[i]-s[k])$此时我们只要找到最小的k就可以了，我们发现现在的情况和前面提到的货仓选址问题一模一样所以k就是s数组的中位数 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; #define ll long long ll n; ll a[5000050],s[5000050]; ll abss(ll x) { if(x&gt;0)return x; else return -x; } int main() { scanf(&quot;%d&quot;,&amp;n); ll pjs=0; for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]),pjs+=a[i]; pjs/=n; for(int i=1;i&lt;=n;i++)s[i]=s[i-1]+a[i]-pjs; sort(s+1,s+n+1); int k=n/2; ll answer=0; for(int i=1;i&lt;=n;i++)answer+=abss(s[i]-s[k]); printf(&quot;%lld&quot;,answer); return 0; }","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"/tags/%E8%B4%AA%E5%BF%83/"}],"author":"Tian-Xing"},{"title":"洛谷P2783有机化学之神偶尔会作弊","slug":"洛谷P2783有机化学之神偶尔会作弊","date":"2019-09-08T02:32:02.000Z","updated":"2019-10-18T07:19:52.181Z","comments":true,"path":"2019/09/08/洛谷P2783有机化学之神偶尔会作弊/","link":"","permalink":"/2019/09/08/%E6%B4%9B%E8%B0%B7P2783%E6%9C%89%E6%9C%BA%E5%8C%96%E5%AD%A6%E4%B9%8B%E7%A5%9E%E5%81%B6%E5%B0%94%E4%BC%9A%E4%BD%9C%E5%BC%8A/","excerpt":"","text":"这题不难qwq但是卡了我好长时间 题意给出一张无向图，每次删去一个e-DCC(边双连通分量），重新建图，然后求两点所在e-DCC之间距离。 思路这道题的题意非常的显然，所以我们只要直接按照题意做一遍就好了。 最后求两点之间距离的时候，求一个LCA即可，答案就是d[a]+d[b]-2* d[lca（a,b）]+1所以这道题就做完了(雾 小bug我们交上了代码，心满意足的期待着又一道黑题的ac，但是突然结果出现，只有73pts。怎么回事啊？？？ 这就是本题解最重要的部分边双联通分量有有两种方法，其中一种是求出所有割边，然后依次删去。这样剩下的图就被分成了很多单独的部分，每一个部分就是一个e-DCC 另一种方法则和有向图的缩点相似，我们用一个栈记录搜索树上的点，当low[x]=dfn[x]的时候将stack里的点依次退出，一直退到x，我们便求出了一个e-DCC 注意：最下方题面里说两个点不删去所以当我们tarjan的时候遇到x的父亲就直接continue,按这个思路法二可以过。 但是法一即使加上这个判断也过不了，所以还是不写法一比较好(雾 73ptsCODE#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;cmath&gt; using namespace std; #define N 100500 #define M 500500 int n,m,head[N],num=1,dfn[N],low[N],cnt,bridge[M],he[N],sy[N],numm,t,f[N][50],d[N]; queue&lt;int&gt; q; struct node { int next,to; }edge[M*2],tu[M*2]; void addedge(int u,int v) { edge[++num]=(node){head[u],v}; head[u]=num; } void newaddedge(int u,int v) { tu[++numm]=(node){he[u],v}; he[u]=numm; } void tarjan(int x,int in_edge) { low[x]=dfn[x]=++cnt; for(int i=head[x];i;i=edge[i].next) { int v=edge[i].to; if(!dfn[v]) { tarjan(v,i); low[x]=min(low[x],low[v]); if(dfn[x]&lt;low[v])bridge[i]=bridge[i^1]=1; } else if(i!=(in_edge^1))low[x]=min(low[x],dfn[v]); } } void jb(int x,int syy) { for(int i=head[x];i;i=edge[i].next) { int v=edge[i].to; if(bridge[i]||sy[v])continue; sy[v]=syy; jb(v,syy); } } void bfs() { q.push(1); d[1]=1; while(!q.empty()) { int u=q.front(); q.pop(); for(int i=he[u];i;i=tu[i].next) { int v=tu[i].to; if(d[v])continue; d[v]=d[u]+1; f[v][0]=u; for(int k=1;k&lt;=t;k++)f[v][k]=f[f[v][k-1]][k-1]; q.push(v); } } } int lca(int a,int b) { if(d[a]&lt;d[b])swap(a,b); for(int i=t;i&gt;=0;i--)if(d[f[a][i]]&gt;=d[b])a=f[a][i]; if(a==b)return a; for(int i=t;i&gt;=0;i--)if(f[a][i]!=f[b][i])a=f[a][i],b=f[b][i]; return f[a][0]; } void xs(int shu) { int answer[500000],kkk=0; while(shu) { answer[++kkk]=shu%2; shu/=2; } for(int i=kkk;i&gt;=1;i--)printf(&quot;%d&quot;,answer[i]); printf(&quot;\\n&quot;); } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addedge(u,v);addedge(v,u); } for(int i=1;i&lt;=n;i++)if(!dfn[i])tarjan(i,0); cnt=0; for(int i=1;i&lt;=n;i++)if(!sy[i])sy[i]=++cnt,jb(i,cnt); for(int i=2;i&lt;=num;i++)if(sy[edge[i].to]!=sy[edge[i^1].to])newaddedge(sy[edge[i].to],sy[edge[i^1].to]); t=(int)(log(cnt)/log(2))+1; bfs(); int tot; scanf(&quot;%d&quot;,&amp;tot); for(int i=1;i&lt;=tot;i++) { int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); a=sy[a];b=sy[b]; int lcab=lca(a,b); xs(d[a]+d[b]-2*d[lcab]+1); } return 0; } 100ptsCODE#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;cmath&gt; using namespace std; #define N 100500 #define M 500500 int stack[N],top,ttt,n,m,head[N],num=1,dfn[N],low[N],cnt,bridge[M],he[N],sy[N],numm,t,f[100050][50],d[N]; queue&lt;int&gt; q; struct node { int next,to; }edge[M*2],tu[M*2]; void addedge(int u,int v) { edge[++num]=(node){head[u],v}; head[u]=num; } void newaddedge(int u,int v) { tu[++numm]=(node){he[u],v}; he[u]=numm; } void tarjan(int x,int fa) { low[x]=dfn[x]=++cnt; stack[++top]=x; for(int i=head[x];i;i=edge[i].next) { int v=edge[i].to; if(v==fa)continue; if(!dfn[v]) { tarjan(v,x); low[x]=min(low[x],low[v]); } else low[x]=min(low[x],dfn[v]); } if(low[x]==dfn[x]) { sy[x]=++ttt; while(stack[top]!=x)sy[stack[top]]=ttt,top--; top--; } } void jb(int x) { sy[x]=cnt; for(int i=head[x];i;i=edge[i].next) { int v=edge[i].to; if(bridge[i]||sy[v])continue; jb(v); } } void bfs() { q.push(1); d[1]=1; while(!q.empty()) { int u=q.front(); q.pop(); for(int i=he[u];i;i=tu[i].next) { int v=tu[i].to; if(d[v])continue; d[v]=d[u]+1; f[v][0]=u; for(int k=1;k&lt;=t;k++)f[v][k]=f[f[v][k-1]][k-1]; q.push(v); } } } int lca(int a,int b) { if(d[a]&lt;d[b])swap(a,b); for(int i=t;i&gt;=0;i--)if(d[f[a][i]]&gt;=d[b])a=f[a][i]; if(a==b)return a; for(int i=t;i&gt;=0;i--)if(f[a][i]!=f[b][i])a=f[a][i],b=f[b][i]; return f[a][0]; } void xs(int shu) { int answer[500000],kkk=0; while(shu) { answer[++kkk]=shu%2; shu/=2; } for(int i=kkk;i&gt;=1;i--)printf(&quot;%d&quot;,answer[i]); printf(&quot;\\n&quot;); } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addedge(u,v);addedge(v,u); } for(int i=1;i&lt;=n;i++)if(!dfn[i])tarjan(i,0); cnt=0; // for(int i=1;i&lt;=n;i++)if(!sy[i]){++cnt;jb(i);} for(int i=2;i&lt;=num;i++)if(sy[edge[i].to]!=sy[edge[i^1].to])newaddedge(sy[edge[i].to],sy[edge[i^1].to]); t=32; bfs(); int tot; scanf(&quot;%d&quot;,&amp;tot); for(int i=1;i&lt;=tot;i++) { int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); a=sy[a];b=sy[b]; int lcab=lca(a,b); xs(d[a]+d[b]-2*d[lcab]+1); } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Tarjan","slug":"Tarjan","permalink":"/tags/Tarjan/"},{"name":"双连通分量","slug":"双连通分量","permalink":"/tags/%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"}],"author":"Tian-Xing"},{"title":"SCOI2016背单词","slug":"SCOI2016背单词","date":"2019-09-03T13:50:41.000Z","updated":"2019-10-18T07:18:49.827Z","comments":true,"path":"2019/09/03/SCOI2016背单词/","link":"","permalink":"/2019/09/03/SCOI2016%E8%83%8C%E5%8D%95%E8%AF%8D/","excerpt":"","text":"题意解释（本题最重要的部分）本篇题解过于详细，适合初学者食用 给你一些字符串，让你对其进行排列，使得按以下规则花费最少(然而题意真的不清楚，很容易就让人以为字符串的顺序是排好的) （$x$为字符串在自行排定的序列中的位置，当前字符串为$a$)1.如果$a$存在后缀且a的后缀在a之后，花费$+=n^2$2.如果$a$不存在后缀则花费$+=x$3.设$y$为$a$之前离其最近的是$a$的后缀的字符串的位置，$a$存在后缀且$a$的后缀在$a$之前，则花费$+=x-y$ 经过转化题意就比较显然了，但是我们如果仔细读题我们发现1，2规则其实完全没有必要。 规则1我们只要把$a$的后缀放在$a$之前就好了，这样肯定优于放在$a$的后面因为$x-y$的值最大只能是n-1显然优于$n^2$ 规则2我们发现其实就是规则三中$y=0$的特殊情况，直接当规则3来处理就好 大体思路看到后缀我们显然首先想到的是后缀数组，但是本蒟蒻太弱了不会怎么办？？？（而且本蒟蒻也不知道本题能不能用后缀数组） 我们把字符串翻个顺序就会发现后缀其实就是前缀，所以我们可以翻转字符串，处理前缀。 而处理前缀我们首先就会想到trie字典树，座椅本题我们采用建立trie字典树的做法。 看懂题目的规则之后我们发现可以贪心的求解此题，只要让字符串的后缀与字符串之间所隔的字符串数目最小即可 所以第一步我们建立一颗trie树 第二步我们发现一个字符串有可能有很多后缀，所以我们需要判重，这里使用并查集 优于字符串的后缀与字符串之间存在有向的关系，便建立一张有向图。$x-&gt;y$代表$x$是$y$的后缀 因为要保证字符串与字符串的后缀之间距离最小所以贪心的选取以x为根的最小的子树 （使用vector在算出每棵子树大小后进行排序即可）最后按照规则求和 求和时使用dfs序的正确性的证明如果你有认真看我的或其他人的题解，你可以发现我们在最后求和的时候是按照dfs序的。那么为什么？（我不会） 所以我在夏令营时找了wqy神仙讲解。 考虑重新建树之后，i节点的子树中的所有节点的后缀都是i 如果同一深度上有不止一棵子树，那么我们先在一棵上取出一个叶子节点j，再取出一个根节点i，我们发现如果j&gt;i的话肯定不如i&lt;j优秀 因为调整之后i的子树上所有节点对花费的贡献-=子树大小，j对花费的贡献+1，所以我们可以看到j&gt;i的花费&lt;=i&gt;j的情况 最后我们经过所有的调整可以发现序列变成了dfs序 所以dfs序最优，而bfs序在有的时候可以满足这一性质，有的时候则不能，所以不是最优的（只能拿部分分） 还是感谢wqy，给了我很大的帮助，然而我不知道他的洛谷id QAQAQ CODE#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; #define N 510050 #define M 100050 #define ll long long ll ans=0; char x[N]; int n,cnt,bo[N],tot=1,trie[5000050][27],fa[N],id[N],son[N],num; vector&lt;int&gt;tu[N]; int read() { int s=0,p=1; char ch=getchar(); while(ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if(ch==&#39;-&#39;)p=-1; ch=getchar(); } while(ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+(ch^48); ch=getchar(); } return s*p; } int find(int x) { if(fa[x]==x)return fa[x]; else return fa[x]=find(fa[x]); } void insert(char *s,int bh) { int l=strlen(s); int u=1; for(int i=l-1;i&gt;=0;i--) { int c=s[i]-&#39;a&#39;; if(!trie[u][c])trie[u][c]=++tot; u=trie[u][c]; } bo[u]=bh; } void make(int x) { for(int i=0;i&lt;26;i++) { int v=trie[x][i]; if(v) { if(!bo[v]) { fa[v]=find(x); } else { tu[bo[find(x)]].push_back(bo[v]); } make(v); } } } int cmp(int x,int y) { return son[x]&lt;son[y]; } void sonsum(int x) { son[x]=1; for(vector&lt;int&gt; :: iterator it=tu[x].begin();it!=tu[x].end();it++) { int v=*it; sonsum(v); son[x]+=son[v]; } sort(tu[x].begin(),tu[x].end(),cmp); } void dfs(int x) { id[x]=num++; for(vector&lt;int&gt; :: iterator it=tu[x].begin();it!=tu[x].end();it++) { int v=*it; ans+=num-id[x]; dfs(v); } } void dfss(int x) { for(vector&lt;int&gt; :: iterator it=tu[x].begin();it!=tu[x].end();it++) { int v=*it; cout&lt;&lt;v&lt;&lt;endl; dfss(v); } } int main() { n=read(); for(int i=1;i&lt;=n;i++) { scanf(&quot;%s&quot;,x); insert(x,i); } for(int i=1;i&lt;=tot;i++)fa[i]=i; make(1); sonsum(0);dfs(0); printf(&quot;%lld&quot;,ans); return 0; } 并查集去重的思路来源于此篇blog","categories":[{"name":"题解","slug":"题解","permalink":"/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"TRIE","slug":"TRIE","permalink":"/tags/TRIE/"},{"name":"DFS","slug":"DFS","permalink":"/tags/DFS/"}],"author":"Tian-Xing"},{"title":"洛谷P1020导弹拦截","slug":"洛谷P1020导弹拦截","date":"2019-09-02T12:56:56.000Z","updated":"2019-10-18T07:20:08.251Z","comments":true,"path":"2019/09/02/洛谷P1020导弹拦截/","link":"","permalink":"/2019/09/02/%E6%B4%9B%E8%B0%B7P1020%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA/","excerpt":"","text":"导弹拦截这道题可以用树状数组、线段树什么的优化 但是我一个都不会 而这道题的数据范围又很大 c++奥赛一本通（meng）上o(n2）的算法过不了 所以本蒟蒻来说一个o(nlogn)的算法 问题转换第一问很容易就可以想到是求一个最长不上升子序列 但是第二问就需要一个转换的思想了 我们可以把问题中需要几组导弹转化成求一个最长上升子序列 证明：1、首先我们把这些导弹分为s组（s即为所求答案） 可以看出每一组都是一个不升子序列 2、划分完后我们在组一里找一个原序列里以组一的开头点连续的不升子串的最后一个元素，可以知道在组2中一定有一个大与它的点 （如果组二中没有的话，那么组二中最高的导弹高度必然小于这个点，而其他的高度都小于这个高度而且是递减或相等的，那么没有必要再开一个组二了，矛盾，所以不存在找不到比他大的点的情况） 3、以此类推，对于每一个k组（1&lt;=k&lt;n）都可以找到这样的一些点 所以把这些点连起来，就是一条上升子序列。 4、设最长上升子序列长度为l 所求上升子序列为h 那么h&lt;=l 因为最长上升子序列任意两个不在一组内 (如果在同一个组内，则每个组的数不成为一个不生子序列，矛盾） 所以l==h 比较难理解 我们来看组数据 389 207 155 300 299 170 158 65 组一 389 207 155 65组二 300 299 170 158 步骤一中我们一开始找到的点是1 因为如果找65不好解释，所以我们找原数列里连续的最后一个即155 组二里可以找到300比他大 所以最长上升子序列长度为2==答案 问题求解到这里我们发现只要求最长不升子序列和最长上升子序列就好了 下面说最长上升子序列的o(nlogn)求法（最长不升子序列同理） 数组a为要求的数列 首先我们开一个数组k k[lis]记录lis长的上升子序列的最后一个数 len表示最长的长度 初始化len=0，k[0]=-无限 我们可以很轻松的看出k是一个有序的（递增） 如果a[i](1&lt;=i&lt;=n）&gt;k[len] k[len=1]=i; 不然每次在k里面二分查找第一个大于等于它的数，下标为x 比较大小，k[x]=min(k[x],a[i]) 因为我们要求最长的，所以我们要尽可能的让最后一位小（贪心思想） 最后输出len即可 证明 k数组一定是一个有序的上升序列 因为它记录的是长为x的上升序列的最后一位 如果不是上升的，那么它必然可以加入以k[x+1]结尾的上升序列，矛盾 复杂度每次最坏要二分查找（log len）一共要n次len&lt;=n所以算法复杂度为o(nlogn) 过这个题稳得一批 代码#include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int i,g[10000000],a[10000000],len,k[10000000],zen; const int inf=0x7f7f7f7f; int main() { g[0]=-inf; k[0]=inf; while(cin&gt;&gt;a[++i]) { if(a[i]&lt;=k[zen]){zen++;k[zen]=a[i];} else { int h=0,d=zen,mid; while(h&lt;d) { mid=(h+d)&gt;&gt;1; if(k[mid]&gt;=a[i]) h=mid+1; else d=mid; }//二分在k数组里找第一个小于a[i]的数 k[h]=max(k[h],a[i]);//进行比较，贪心思想 } if(a[i]&gt;g[len]) { len++; g[len]=a[i]; continue; } int x=0,y=len,mid; while(x&lt;y) { mid=(x+y)&gt;&gt;1; if(g[mid]&gt;=a[i]) y=mid; else x=mid+1; }//二分在g数组里找第一个大于等于a[i]的数 g[x]=min(g[x],a[i]);//进行比较，贪心思想 } cout&lt;&lt;zen&lt;&lt;endl&lt;&lt;len; return 0; } 文章中关于对求最长上升子序列的证明，部分参考了这位大佬的题解，致以最诚挚的感谢jjpjj的证明方法 谨以此题纪念我的luogu绿名","categories":[{"name":"题解","slug":"题解","permalink":"/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"DP","slug":"DP","permalink":"/tags/DP/"},{"name":"二分答案","slug":"二分答案","permalink":"/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"}],"author":"Tian-Xing"},{"title":"Tian-Xing的任务计划","slug":"Tian-Xing的任务计划","date":"2019-08-27T23:42:57.000Z","updated":"2019-10-18T07:18:24.476Z","comments":true,"path":"2019/08/28/Tian-Xing的任务计划/","link":"","permalink":"/2019/08/28/Tian-Xing%E7%9A%84%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/","excerpt":"","text":"emmmmm小蒟蒻真是不知道该学什么好了毕竟没学过的东西太多了点马上就要csp2019了真心自闭目前的任务计划：1.复习完DP2.复习完图论3.复习完基础数据结构4.学习分块5.学习莫队6.学习网络流7.学习概率DP","categories":[],"tags":[],"author":"Tian-Xing"},{"title":"Tian-Xing犯过的错误","slug":"Tian-Xing犯过的错误","date":"2019-08-27T23:42:40.000Z","updated":"2019-10-18T07:18:13.684Z","comments":true,"path":"2019/08/28/Tian-Xing犯过的错误/","link":"","permalink":"/2019/08/28/Tian-Xing%E7%8A%AF%E8%BF%87%E7%9A%84%E9%94%99%E8%AF%AF/","excerpt":"","text":"1.线段树pushdown一定要分开写，遇见有关精度的问题一定要先把有关精度的变量预处理成一个变量，不能一边算一边做。2.数学题记得不停地用模数取模防止爆long long，保险起见用快速乘。 ll mul(ll a,ll b,ll p) { return (a*b-(ll)((long double)a/p*b)*p+p)%p; } 3.spfa记得vis[u]=0。4.倍增求LCA记得从大到小的顺序跳，还要避免变量名冲突,记得初始节点深度是15.广搜的时候记得把v加入队列6.可并堆记得使用并查集路径压缩维护7.合并并查集使用启发式合并8.写spfa时记得加小优化：把队尾的值与队首+1的值比较，较小的扔前面，较大的扔后面9.dp时记得初始化，数组下标要注意，千万不要越界10.结构体里的二维数组不要开太大会爆掉11.2019洛谷秋令营模拟赛tB，我将minn的初值赋为了1e9，开心的拿到了10pts的好成绩，比赛后我觉得算法比较正确，将minn的初值改为了9999999999999999，于是拿到了100pts的好成绩12.还是那场比赛(真是降智 TA的滚动数组没有清零…… 所以这是血的教训：滚动数组记得要清零13.线段树记得询问和修改不要把(l,r)和(x,y)区间写反14.主席树向函数里传递root[x]而不是x","categories":[],"tags":[],"author":"Tian-Xing"},{"title":"Tian-Xing见过的定理","slug":"Tian-Xing见过的定理","date":"2019-08-27T23:42:08.000Z","updated":"2019-10-18T07:18:03.190Z","comments":true,"path":"2019/08/28/Tian-Xing见过的定理/","link":"","permalink":"/2019/08/28/Tian-Xing%E8%A7%81%E8%BF%87%E7%9A%84%E5%AE%9A%E7%90%86/","excerpt":"","text":"n!的质因数分解定理：定理：对于小于 n 的质数 p，n!中含有因子 p 的个数为：$ n/p+n/p^2+…+n/p^k $ （其中 k为$ p^k&lt;=n $的最大值） 可重集元素的排列组合：在 S 中任选 r 个元素的排列称为S的r排列$ |$多重组合数，当r = n时，有公式 $P(n; n1* a1, n2* a2, …, nk* ak) = n! / (n1! * n2! * …* nk!) $在 S 中任选 r 个元素的组合称为S的r组合，当r&lt;=任意ni时，有公式 $C(n; n1* a1, n2* a2, …, nk * ak) = C(k+r-1, r) $ 约数和：对于一个数N，如果它的标准分解式为$N=p_1^{a_1}p_2^{a_2}p_3^{a_3}…p_n^{a_n} $ 那么约数和$ S= \\prod _ {i=1}^ n \\sum _ {j=0} ^{ a i} p_ i ^j $ （$ p_1 ,p_2……p_n $ 为质数） 那么约数个数$ S=\\prod _ {i=1} ^n (a_i +1) $ 威尔逊定理$(p-1)! \\equiv p-1(\\mod p) $考虑如果这p-1个数中如果一个数是一个数的逆元那么这两个数都会被消去，留下的都是逆元是本身的数若一个数的逆元等于本身则有 $ x \\equiv x^{-1} (\\mod p)$那么$ x^2 -1\\equiv 0 (\\mod p)$所以$p|(x+1) $ 或者$ p|(x-1)$所以$ p-1$的逆元是他本身","categories":[],"tags":[],"author":"Tian-Xing"}]}